[toc]

# 《图解MySQL》

## 一、基础篇

### 1.1 执行一条select语句，期间发生了什么？

**1. MySQL执行流程是怎样的？**

Server层和存储索引层

**2. 第一步：连接器**

- 与客户端进行TCP三次握手建立连接
- 检验客户端的用户名和密码，不对则报错
- 用户名和密码都对了后，读取用户的权限，后续权限逻辑判断基于此时读到的权限

**3. 第二步：查询缓存**

对查询语句（select），MySQL先到查询缓存（Query Cache）里查找缓存数据，其中数据以key-value保存，key为查询语句，value为查询结果。

然而当表有更新时，表的查询缓存被清空，对于更新频繁的表，缓存容易变得多余。因此在MySQL 8.0开始，将查询缓存删掉了。

**4. 第三步：解析SQL**

解析器，做词法分析和语法分析，负责检查语法和构建语法树。

**5. 第四步：执行SQL**

- prepare阶段
- optimize阶段
- execute阶段

**预处理器**：检查查询语句中的表或字段是否存在，将`select *`的`*`符号扩展为表的所有列

**优化器**：确定查询语句执行方案

**执行器**：与存储引擎交互，以记录为单位

- 主键索引查询
- 全表扫描
- 索引下推



**1.2 MySQL一行记录是怎么存储的？**

**1. MySQL的数据存放在哪个文件？**

`/var/lib/mysql/database_name/`，其中`db.opt`存储当前数据库的默认字符集和字符校验规则，`.frm`文件保存表结构，`.ibd`文件保存表数据。

**表空间文件的结构是怎么样的？**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\基础篇\表空间结构.drawio.png)

**2. InnoDB行格式有哪些？**

**3. COMPACT行格式长什么样？**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\基础篇\COMPACT.drawio.png)

**记录的额外信息**

- 变长字段长度列表
- NULL值列表
- 记录头信息

**记录的真实数据**

- row_id
- trx_id
- roll_pointer

**4. varchar(n)中n最大取值为多少？**

**单字段的情况**

**多字段的情况**

**5. 行溢出后，MySQL是怎么处理的？**

**6. 总结**



## 二、索引篇

### 2.1 索引常见面试题

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\索引提纲.png)

**1. 什么是索引？**

**2. 索引的分类**

- 按数据结构：B+tree索引、Hash索引、Full-text索引
- 按物理存储：聚簇索引（主键索引）、二级索引（辅助索引）
- 按字段特性：主键索引、唯一索引、普通索引、前缀索引
- 按字段个数：单列索引、联合索引

**按数据结构分类**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\索引分类.drawio.png)

B+Tree是一种多叉树，叶子节点才存放数据，非叶子节点存放索引，每个节点里的数据按主键顺序存放。每个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

![主键索引 B+Tree](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\btree.drawio.png)

通过主键查询商品数据的过程

通过二级索引查询商品数据的过程

为什么MySQL InnoDB选择B+tree作为索引的数据结构？

**按物理存储分类**

**按字段特性分类**

- 主键索引
- 唯一索引
- 普通索引
- 前缀索引

**按字段个数分类**

单列索引、联合索引（复合索引）

联合索引

联合索引范围查询

索引下推

索引区分度

联合索引进行排序

**3. 什么时候需要/不需要创建索引？**

**什么时候适用索引？**

- 字段有唯一性限制
- 经常用于`WHERE`查询条件的字段
- 经常用于`GROUP BY`和`ORDER BY`的字段

**什么时候不需要创建索引？**

- `WHERE`条件、`GROUP BY`、`ORDER BY`里用不到的字段
- 字段存在大量重复数据
- 表数据太少
- 经常更新的字段

**4. 有什么优化索引的方法？**

**前缀索引优化**

**覆盖索引优化**

**主键索引最好是自增的**

**索引最好设置为NOT NULL**

**防止索引失效**

**5. 总结**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\索引总结.drawio.png)



### 2.2 从数据页的角度看B+树

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\数据页角度下的B+树提纲.png)

**1. InnoDB是如何存储数据的？**

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\数据页结构.png)

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\数据页各部分作用.png)

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\页目录与记录关系.png)

**2. B+树是如何进行查询的？**

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\InnoDB里B+树结构.png)

**3. 聚簇索引和二级索引**

**4. 总结**



### 2.3 为什么MySQL采用B+树作为索引？

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\B+树作为索引提纲.png)

**1. 怎样的索引的数据结构是好的？**

- 能在尽可能少的磁盘的I/O操作中完成查询工作
- 要能高效地查询某个记录，也能高效执行范围查找

**2. 什么是二分查找？**

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\二分查找例子.png)

查询时间复杂度O(logn)

**3. 什么是二分查找树？**

**4. 什么是自平衡二叉树**

平衡二叉查找树（AVL树）、红黑树

**5. 什么是B树**

**6. 什么是B+树？**

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\B+树结构.png)

**单点查询**

**插入和删除效率**

**范围查询**

**MySQL中的B+树**

**7. 总结**



### 2.4 MySQL单表不要超过2000W行，靠谱吗？

**1. 实验**

**2. 单表数量限制**

**3. 表空间**

**4. 页的数据结构**

**5. 索引的数据结构**

**6. 单表建议值**

**7. 总结**



### 2.5 索引失效有哪些？

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\索引失效提纲.png)

**1. 索引存储结构长什么样？**

**2. 对索引使用左或者左右模糊匹配**

**3. 对索引使用函数**

**4. 对索引进行表达式计算**

**5. 对索引隐式类型转换**

**6. 联合索引非最左匹配**

**7. WHERE子句中的OR**



### 2.6 MySQL使用like “%x”，索引一定会失效吗？



### 2.7 count(*)和count(1)有什么区别？哪个性能最好？

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\count提纲.png)

**1. 哪种count性能最好？**

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\索引篇\count性能排序.png)

**count()是什么？**

**count(主键字段)执行过程是怎样的？**

**count(1)执行过程是怎样的？**

**count(*)执行过程是怎样的？**

**count(字段)执行过程是怎样的？**

**小结**

**2. 为什么要通过遍历的方式来计数？**

**3. 如何优化count(*)？**

**第一种，近似值**

**第二种，额外表保存计数值**





## 三、事务篇

### 3.1 事务隔离级别是怎么实现的？

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\事务篇\事务提纲.png)

**1. 事务有哪些特性**

- 原子性（Atomicity）：undo log
- 一致性（Consistency）
- 隔离性（Isolation）：MVCC
- 持久性（Durability）：redo log

**2. 并行事务会引发什么问题？**

**赃读**：事务读到另一个未提交事务已修改过的数据

**不可重复读**：一个事务内多次读取同一个数据，前后两次读结果不一样

**幻读**：一个事务内多次查询符合某个查询条件的记录数量，前后结果不一样

**3. 事务的隔离级别有哪些？**

并行事务问题严重性：赃读 > 不可重复读 > 幻读

隔离级别

- 读未提交（read uncommitted）：事务未提交，其变更就能被其他事务看到了
- 读提交（read committed）：事务提交后，变更才能被其他事务看到
- 可重复读（repeatable read）：事务执行中看到的数据，一直和事务启动时看到的一致。MySQL InnoDB引擎默认隔离级别
- 串行化（serializable）：对记录加读写锁，多事务对该记录进行读写操作时，发生读写冲突时，后访问事务必须等前一个事务执行完成才能继续执行

隔离水平高低：串行化 > 可重复读 > 读已提交 > 读未提交

隔离级别约高，性能效率越低

不同隔离级别会出现的并发事务问题

- 读未提交：赃读、不可重复读、幻读
- 读提交：不可重复读、幻读
- 可重复读：幻读
- 串行化：都不会发生

但不建议升级到串行化级别，会影响性能

MySQL InnoDB默认隔离级别可重复读，也能在很大程度上避免幻读现象，解决方案有两：

- 针对快照读（普通select语句），使用MVCC
- 针对当前读（select ... for update等语句），使用next-key lock（记录锁+间隙锁）方式解决幻读

四种隔离级别实现：

- 读未提交：读到未提交事务修改过的数据，直接读取最新数据
- 串行化：加读写锁避免并行访问
- 读提交和可重复读都通过Read View实现，区别在于创建Read View（数据快照）时机不同。读提交在事务的每条语句执行前都重新生成一个Read View，而可重复读只在启动事务时生成，整个事务期间都用这个Read View

**4. Read View在MVCC里如何工作的？**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\事务篇\readview结构.drawio.png)

Read View四个重要字段

- m_ids：
- min_trx_id：
- max_trx_id：不是m_ids最大值，而是全局事务中最大事务id值+1
- creator_trx_id：创建该Read View的事务的事务id

![图片](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\事务篇\聚簇索引隐藏列.png)

InnoDB存储引擎的聚簇索引记录包含两个隐藏列：

- trx_id：事务对某条聚簇索引记录改动时，将事务id记录在trx_id里
- roll_pointer：每次对某条聚簇索引记录改动时，都会将旧版本的记录写入undo日志中，然后roll_pointer指向旧版本记录

创建Read View后，可以将记录的trx_id划分三种情况：

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\事务篇\ReadView.drawio.png)

一个事务访问记录时，除了自己的更新记录总是可见外，还有几种情况

- 如果记录的trx_id值小于Read View中的min_trx_id，说明记录是在创建Read View前已提交的事务生成的，该版本记录对当前事务可见
- 如果trx_id大于Read View中的max_trx_id，说明记录是在Read View创建后启动的事务生成的，不可见
- 如果trx_id在min_trx_id和max_trx_id之间，需要判断trx_id是否在m_ids列表中。如果存在，说明生成该版本记录的活跃事务依然活跃着，记录不可见；如果不存在，则说明生成该版本记录的活跃事务已经被提交了，可见。

通过版本链来控制并发事件访问同一个记录的行为，称**MVCC（多版本并发控制）**



**5. 可重复读是如何工作的？**

**6. 读提交是如何工作的？**

**7. 总结**



### 3.2 MySQL可重复读隔离级别，完全解决幻读了吗？

**1. 什么是幻读？**

**2. 快照读是如何避免幻读的？**

**3. 当前读是如何避免幻读的？**

**4. 幻读被完全解决了吗？**

**第一个发生幻读现象的场景**

**第二个发生幻读现象的场景**

**5. 总结**

MySQL可重复读隔离级别并没有完全解决幻读，只是很大程度上避免了幻读的发生

要避免这类幻读现象，就尽量从开启事务后，马上执行select ... for update这类当前读的语句，因为会对记录加next-key lock，从而避免其他事务插入一条记录。



## 四、锁篇

### 4.1 MySQL有哪些锁？

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\锁篇\锁提纲.png)

**1. 全局锁**

执行`flush tables with read lock`，整个数据库就处于只读状态，以下操作会被阻塞：

- 对数据增删改，如insert、delete、update等语句
- 对表结构的更改操作，如alter table、drop table等语句

释放全局锁`unlock tables`

**2. 表级锁**

**表锁**

**元数据锁**

**意向锁**

**AUTO-INC锁**

**3. 行级锁**

**Record Lock**：记录锁，锁定记录

**Gap Lock**：间隙锁，锁定范围，不锁定记录

**Next-Key Lock**：临键锁，Record Lock + Gap Lock

**插入意向锁**



### 4.2 MySQL是怎么加锁的？

**1. 什么SQL语句会加行级锁？**

**2. 行级锁有哪些种类？**

**3. MySQL是怎么加行级锁的？**

**唯一索引等值查询**

- 记录存在的情况
- 记录不存在的情况

**唯一索引范围查询**

- 针对大于的范围查询
- 针对大于等于的范围查询
- 针对小于或小于等于的范围查询，条件值的记录不在表中
- 针对小于等于，条件值在表中
- 针对小于，条件值在表中

**非唯一索引等值查询**

- 记录不存在的情况
- 记录存在的情况

**非唯一索引范围查询**

**没有加索引的查询**

**4. 总结**

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\锁篇\唯一索引加锁流程.jpeg)

![img](C:\Users\hp-pc\Desktop\实习备战记\MySQL\img\锁篇\非唯一索引加锁流程.jpeg)





### 4.3 update没加索引会锁全表？

**1. 为什么会发生这种的事故？**

**2. 如何避免这种事故的发生？**



### 4.4 MySQL记录锁+间隙锁可以防止删除操作而导致的幻读吗？

**1. 什么是幻读？**

**2. 实验验证**

**3. 加锁分析**



### 4.5 MySQL死锁了，怎么办？

**1. 死锁的发生**

**2. 为什么会产生死锁？**

**3. Insert语句是怎么加行级锁的？**

- 记录之间加有间隙锁
- 遇到唯一键冲突

**4. 如何避免死锁**



### 4.6 字节面试：加了什么锁，导致死锁的？

**1. 准备工作**

**2. 开始实验**

**3. 为什么会发生死锁？**



## 五、日志篇

### 5.1 MySQL日志：undo log、redo log、binlog有什么用？

**1. 为什么需要undo log？**

**2. 为什么需要Buffer Pool？**

**Buffer Pool缓存什么？**

**3. 为什么需要redo log？**

**redo log什么时候刷盘？**

**redo log文件写满了怎么办？**

**4. 为什么需要binlog？**

**redo log和binlog有什么区别？**

**主从复制是怎么实现？**

**binlog什么时候刷盘？**

**5. 为什么需要两阶段提交？**

**两阶段提交的过程是怎样的？**

**异常重启会出现什么现象？**

**两阶段提交有什么问题？**

**6. MySQL磁盘I/O很高，有什么优化的方法？**

**7. 总结**



## 六、内存篇

### 6.1 揭开Buffer Pool的面纱

**1. 为什么要有Buffer Pool？**

**Buffer Pool有多大**

**Buffer Pool缓存什么？**

**2. 如何管理Buffer Pool？**

**如何管理空闲页？**

**如何管理脏页？**

**如何提高缓存命中率？**

**脏页什么时候会被刷入磁盘？**

**3. 总结**





